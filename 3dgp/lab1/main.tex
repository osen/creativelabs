\documentclass[10pt]{article}

\usepackage[a4paper, total={6in, 10in}]{geometry}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{xcolor}
\usepackage{framed}
\usepackage{environ}
\setlength{\parindent}{0pt}

\input{../../common}

\begin{document}

\title{3D Graphics Programming \\
  \large Lab 1: Rendering a Triangle}

\author{Karsten Pedersen\\ Department of Creative Technology}
\maketitle

In this unit we aim to use an industry standard graphics API to draw
and interact with 3D objects. \Name{OpenGL} as an API is extremely flexible
but also comes with quite a bit of complexity.  Developing with \Name{OpenGL}
can often require some initial time to get used to how it works and also
to set up the data used for the rendering.

\

The first thing we will need to do is to ensure that the project is
set up and ready to use \Name{OpenGL}. To just get a window appearing
on the screen we will be using \Name{SDL 2} because not only is the code
required to do so fairly trivial but also because you are already familiar
with it.  Other libraries that are also common for this task include
\Name{[Free]Glut}, \Name{GLFW}, \Name{SFML} and \Name{Allegro}. Open
the provided \Name{Microsoft Visual Studio} project or generate
the \Name{CMake} build system.  The code inside \Command{main.cpp}
should be familiar to you by now. It simply opens up the \Name{SDL 2}
Window and not much else.  You will see that we are not even creating an
\Command{SDL\_Renderer} because we are going to be using \Name{OpenGL}
directly rather than using the basic renderer provided by \Name{SDL 2}
(which uses either \Name{OpenGL} or \Name{DirectX} underneath depending
on platform).

\Note{
\Name{Microsoft Windows} provides a version of \Name{OpenGL} which
is extremely old (version \textbf{1.2}) and is too inflexible to make
what we see today as modern games. Luckily a much newer implementation
of \Name{OpenGL} is provided by the graphics card manufacturer's driver
(i.e \Name{NVIDIA}, \Name{AMD}, \Name{Intel}, \Name{MESA}). As of writing
we are at around version \textbf{4.6} which only the very latest hardware
supports.  However the techniques and functionality covered in these labs
was actually provided by version \textbf{2.1} which means that your code
will work on almost all hardware found in the wild, even on mobile
devices such as \Name{Android} and \Name{iOS} via \Name{OpenGL ES}.

\

For convenience, rather than use a specific header and library
(i.e \Command{GL/gl.h}) from each different vendor's SDK, we
instead use a 3rd party library called \Name{Glew} (Open\textbf{GL}
\textbf{E}xtension \textbf{W}rangler). This library links the vendor's
specific implementation with the platforms implementation at runtime so
we can just use \Name{OpenGL} as usual and not worry about the details.

}

First, lets begin by including the \Name{Glew} header file into our
project so we can start using \Name{OpenGL} functions.

\begin{Listing}

  #include <GL/glew.h>

\end{Listing}

We now need to instruct \Name{SDL 2} to create a window that is
suitable for creating an \Name{OpenGL} rendering context. To do this
we need to modify the \Command{SDL\_CreateWindow} function call and pass
\Command{SDL\_WINDOW\_OPENGL} as a parameter.

\begin{Listing}

SDL_Window *window = SDL_CreateWindow("Triangle",
    SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
    WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_RESIZABLE | SDL_WINDOW_OPENGL);

\end{Listing}

Next we need to create an \Name{OpenGL} rendering context within
the created \Name{SDL 2} window and because \Name{Glew} loads the
\Name{OpenGL} library and extensions at runtime we also need to initialize
it. In your project, just after where you open the \Name{SDL 2} window
using \Command{SDL\_CreateWindow}, add the following function calls.

\begin{Listing}

  if(!SDL_GL_CreateContext(window))
  {
    throw std::exception();
  }

  if(glewInit() != GLEW_OK)
  {
    throw std::exception();
  }

\end{Listing}

\Note{
This must be \textbf{after} the call to open the window because otherwise
there is no window for \Name{OpenGL} to bind a context to and the call
will fail.
}

With this in place we are now ready to start with \Name{OpenGL}. What
we are first going to do to confirm everything is working is change
the screen to the color red. The following listing will first set the
current \Name{OpenGL} clear color to red, will then actually instruct
\Name{OpenGL} to clear the screen and finally it will atomically swap the
\Name{OpenGL} memory buffer with that of the screen buffer (to eliminate
flicker). You will want to place this code where you would usually start
drawing to the screen in a standard \Name{SDL 2} application.

\begin{Listing}

  glClearColor(1.0f, 0.0f, 0.0f, 1.0f);
  glClear(GL_COLOR_BUFFER_BIT);
  SDL_GL_SwapWindow(window);

\end{Listing}

\Note{
Unlike when using \Name{SDL} where colors usually range between
\Command{0} and \Command{255} (maximum range of an \Command{unsigned
char}), \Name{OpenGL} instead deals with floating point values and
so not only is a value between \Command{0} and \Command{1} such as
\Command{0.332} possible, it also simplifies many calculations. Floating
point values are also handled very quickly on a maths co-processor
(which is essentially exactly what a graphics card is).

}

With that in place, compile the project and run it. You should hopefully
see a similar output to \Ref{example}.

\Figure{images/example}{A screenshot of our \Name{OpenGL} program simply clearing the screen red}{example}

Now we can finally begin using the core functionality of \Name{OpenGL}. In
3D graphics almost everything is made up of triangles so lets start with
trying to draw one. There is quite a lot of initial work that needs to be
done before we can actually view an image on the screen. \Ref{process}
should give you an overview of the tasks required to do this. This same
code can be reused however so after the initial hurdle, you may find it
surprisingly easy to extend.

\Figure{images/process}{Diagram showing the series of tasks in order to render a triangle}{process}

\subsection*{Preparing the Primitive Shape Data}
We will start with preparing the primitive shape. To do this we need a
list of points that describe our shape (in our case our single triangle).
We will use 3D points (include z component) because we aim to get into
drawing 3D objects. For 2D components such as GUI, you will likely not
include the z component to save memory on the GPU.

\begin{Listing}

  const GLfloat positions[] = {
    -0.5f, 0.5f, 0.0f,
    0.5f, -0.5f, 0.0f,
    -0.5f, -0.5f, 0.0f
  };

\end{Listing}

\Note{

Don't get too hung up on the \Name{OpenGL} types. For example
\Command{GLfloat} is just a typedef. On almost all platforms it will be a
typedef of the standard \Command{float}. The only reason for \Name{OpenGL}
to do this is because it is designed to work on an extremely large
range of platforms unlike i.e \Name{Microsoft DirectX}. For this
reason it cannot guarantee or make the assumption that the platform will provide certain
functionality. In this case it would typedef to the next best thing
(such as a \Command{double}).

}

\Todo{
Have a play with these coordinates and you will notice that by default
\Name{OpenGL} coordinates are between \Command{-1} and \Command{1} in
both the x and y axis.  This is basically the \Name{normalized device
coordinates} and by using a different \Name{Projection} matrix, this
will change. We will cover this in a future lab.
}

When we run the program, this data is in our RAM (or stack). We
want to upload it to the GPU. The following listing will create a new
\Name{Vertex Buffer Object} to store data in, bind it so that it is the
active \Name{VBO} for operations, upload the data to the currently bound
\Name{VBO} and finally unbind the buffer again to return the state back
to normal.

\begin{Listing}

  GLuint positionsVboId = 0;

  // Create a new VBO on the GPU and bind it
  glGenBuffers(1, &positionsVboId);

  if(!positionsVboId)
  {
    throw std::exception();
  }

  glBindBuffer(GL_ARRAY_BUFFER, positionsVboId);

  // Upload a copy of the data from memory into the new VBO
  glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);

  // Reset the state
  glBindBuffer(GL_ARRAY_BUFFER, 0);

\end{Listing}

\Note{
The \Command{GLuint} is again, basically just a typedef of an
\Command{unsigned int}. The reason why we do not have a pointer is because
pointers can only point to memory in RAM or on the stack. The actual
memory we are referring to is on the GPU so instead the best we can do
is use an integer ID and copy over the raw memory containing the data
for the points. This is also what makes systems programming languages
(such as \Name{C}, \Name{C++} and \Name{Rust}) so crucial for games and
embedded programming because non-native things such as \Name{Microsoft
C\#/VB.NET} and \Name{Java} use garbage collectors (which cannot function on
the GPU) and dealing with raw memory in these languages is inefficient
or impossible (instead they have to call into \Name{C} anyway).

}

Now we need to create the \Name{Vertex Array Object (VAO)}. At the
moment you might be wondering why this is needed because the data is
already on the GPU.  In older implementations of \Name{OpenGL} it was
not needed and depending on your drivers it might work without. However
when you start needing to include texture coordinates, vertex normals,
lightmap coordinates, it will start to make more sense why it is now
a required step. \Ref{vao} may help explain the interactions between
these concepts. The following listing will create the \Name{VAO}, bind
it, bind the \Name{VBO} and assign our \Name{VBO} containing the vertex
positions to be our first entry (position \Command{0}). Finally we unbind
the \Name{VBO} and unbind the \Name{VAO} to reset to the default state.

\begin{Listing}

  GLuint vaoId = 0;

  // Create a new VAO on the GPU and bind it
  glGenVertexArrays(1, &vaoId);

  if(!vaoId)
  {
    throw std::exception();
  }

  glBindVertexArray(vaoId);

  // Bind the position VBO and assign it to position 0 on the bound VAO
  glBindBuffer(GL_ARRAY_BUFFER, positionsVboId);
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void *)0);

  // Reset the state
  glBindBuffer(GL_ARRAY_BUFFER, 0);
  glBindVertexArray(0);

\end{Listing}

\FigureFull{images/vao}{Diagram showing the relationship between VBOs, VAOs and shader programs}{vao}

\subsection*{Preparing the Shader Program}
We now have the data that we want to draw uploaded, however the GPU does
not yet know how we want it to be drawn. What we need to do is write
a very small program to upload to the GPU that uses the data to do the
drawing. This small program is known as the shader program.

\Todo{GLSL}
\Todo{Vertex Shader}
\Todo{Fragment Shader}
\Todo{Shader Program (glBindAttribLocation)}
\Todo{A note on using OpenCL to do other stuff, collision, physics, AI/ Good at parallel}

\end{document}
